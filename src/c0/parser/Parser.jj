//JavaCCオプション
options {
	STATIC = false; //マルチスレッド環境で使えるようにするため、falseに
	DEBUG_PARSER = true; //デバッグ情報の出力
	UNICODE_INPUT = true; //日本語を処理する
	JDK_VERSION = "1.6";
}

//パーサクラス
PARSER_BEGIN(Parser)
PARSER_END(Parser)

//スキャナの記述

//文のキーワード
TOKEN: {
	  <INT      : "int">
	| <IF       : "if">
	| <ELSE     : "else">
	| <WHILE    : "while">
	| <FOR      : "for">
	| <RETURN   : "return">
	| <BREAK    : "break">
}

//識別子
TOKEN: {
	<IDENTIFIER: ["A"-"Z", "a"-"z", "_"] (["A"-"Z", "a"-"z", "_", "0"-"9"])*>
}

//整数
TOKEN: {
	<INTEGER: ["1"-"9"] (["0"-"9"])*
			| "0"
	>
}

//空白類
SPECIAL_TOKEN: {
	<WHITESPACE: ([" ", "\f", "\n", "\r", "\t"])+>
}

//一行コメント
//"//"、改行以外の文字（0回以上の繰り返し）、改行文字（省略可能）
SPECIAL_TOKEN: {
	<LINE_COMMENT: "//" (~["\n", "\r"])* ("\n" | "\r\n" | "\r")?>
}

//文字列リテラル
MORE: { <"\""> : IN_STRING }
	<IN_STRING> MORE: {
		  <(~["\"", "\\", "\n", "\r"])+> //二重引用符'"', バックスラッシュ'\', 改行文字'\n', '\r'以外の1回以上の繰り返し
		| <"\\" ~[]> //エスケープコード
}
<IN_STRING> TOKEN: { <STRING: "\""> : DEFAULT }


//パーサの記述

//翻訳単位の処理
//翻訳単位 := {外部宣言}*
file(): {}
{
	(externalDefinition())* <EOF>
}

//外部宣言 :=
//	関数宣言
//	|外部変数宣言
externalDefinition(): {}
{
	  defineFunction()
	| declareGlobalVariable()
}

//関数宣言 :=
//	データ型 単純宣言子 '(' [引数 {',' 引数}* ] ')' 複合文
//宣言子については、仕様を再検討する
defineFunction(): {}
{
	type() <IDENTIFIER> "(" [parameter() ("," parameter())* ] ")" blockStatement()
}

//引数 :=
//	データ型 識別子
parameter(): {}
{
	type() <IDENTIFIER>
}


//外部変数宣言 :=
//{変数宣言}+
declareGlobalVariable(): {}
{
	(declareVariable())+
}

//変数宣言 :=
//データ型 単純宣言子 ['=' 式] ';'
//|データ型 配列宣言子 ';'
declareVariable():
{
	Token token;
	DeclareVariableNode declareVariable;
	DataType dataType;
	IdentifierNode identifier;
	ExpressionNode expression;
}
{
	dataType=type() identifier=primaryExpression() ["=" expression=expression()] ";"
		{
			return new DeclareVariableNode(location(token), identifier, expression);		}
	dataType=type() declareArray() ';'
}

//配列宣言子 :=
//	単純宣言子 '[' 式 ']'
declareArray():
{
	IdentifierNode identifier;
	ExpressionNode expression;
}
{
	identifier=primaryExpression() "[" expression=expression() "]"
		{
			return		}
}

//型の構文
//データ型 :=
//	'int'
int type():
{
	Token token;
	DataType dataType;
}
{
	token=<INT>
		{
			return dataType.INT;
		}
}

//文 :=
//	式文
//	|複合文
//	|条件文
//	|繰り返し文
//	|return文
//	|空文
StatementNode statement():
{
	StatementNode statementNode;
}
{
	( statementNode=expressionStatement()
	| statementNode=blockStatement()
	| statementNode=conditionalStatement()
	| statementNode=iterationStatement()
	| statementNode=returnStatement()
	| statementNode=emptyStatement()
	)*
		{
			return statementNode;		}
}

//複合文 :=
//	'{' [局所変数宣言 {局所変数宣言}* ] {文}* '}'
blockStatement():
{
	Token token;
	List<IdentifierNode> localVariables = new LinkedList<IdentifierNode>(); //ローカル変数
	List<StatementNode> statements = new LinkedList<StatementNode>(); //ブロック文本体
	StatementNode statement;
}
{
	token="{" [declareLocalVariable() (declareLocalVariable())* ] (statement=statement())* { if(statement != null) statements.add(statement); } "}"
	{
		return new BlockNode(location(token), localVariables, statements);	}
}

//局所変数宣言 :=
//	{変数宣言}+
declareLocalVariable():
{
}
{
	(declareVariable())+ {}
}

//条件文 :=
//	if文
//この箇所は削除するか検討する
StatementNode conditionalStatement():
{
	StatementNode conditionalStatementNode;
}
{
	conditionalStatementNode=ifStatement() { return conditionalStatementNode; }
}

//if文 :=
//	'if' '(' 式 ')' 文 ['else' 文]
StatementNode ifStatement():
{
	Token token;
	ExpressionNode conditional;
	StatementNode thenBody;
	StatementNode elseBody;
}
{
	token=<IF> "(" conditional=expression() ")" thenBody=statement() [<ELSE> elseBody=statement()]
	{ return new IfNode(location(token), conditional, thenBody, elseBody); }
}

//繰り返し文 :=
//	while文
//	|for文
StatementNode iterationStatement():
{
	StatementNode iterationStatement;
}
{
	  iterationStatement=whileStatement() { return iterationStatement; }
	| iterationStatement=forStatement() { return iterationStatement; }
}

//while文 :=
//	'while' '(' 式 ')' 文
StatementNode whileStatement():
{
	Token token;
	ExpressionNode conditional;
	StatementNode body;
}
{
	token=<WHILE> "(" conditional=expression() ")" body=statement() { return new WhileNode(location(token), conditional, body); }
}

//for文 :=
//	'for' '(' [式] ';' [式] ';' [式] ')' 文
//初期化部や更新部で複数の式文を実行出来るようするべきか
StatementNode forStatement():
{
	Token token;
	ExpressionNode initialize;
	ExpressionNode conditional;
	ExpressionNode update;
	StatementNode body;
}
{
	token=<FOR> "(" [initialize=expression()] ";" [conditional=expression()] ";" [update=expression()] ")" body=statement()
	{ return new ForNode(location(token), initialize, conditional, update, body); }
}

//return文 :=
//	'return' [式] ';'
StatementNode returnStatement():
{
	Token token;
	ExpressionNode expressionNode;
}
{
	token=<RETURN> [expressionNode=expression()] ";" { return new ReturnNode(location(token), expressionNode); }
}

//空文 :=
//	';'
//あとで見直す
StatementNode emptyStatement():
{
	Token token;
}
{
	token=";" { return new EmptyStatementNode(location(token)); }
}

//式文 :=
//	式 ';'
ExpressionNode expressionStatement():
{
	Token token;
	ExpressionNode expressionNode;
}
{
	expressionNode=expression() ";" { return new ExpressionStatementNode(location(token), expressionNode); }
}

//式の構文
//演算子の優先順位が低い順に書く

//代入式
ExpressionNode expression():
{
	ExpressionNode right;
	ExpressionNode left;
	ExpressionNode expressionNode;
}
{
	  left=term() "=" right=expression() { return new AssignNode(location(token), right, left); }
	| expression5() { return expressionNode; }
}

//論理OR
ExpressionNode expression5():
{
	ExpressionNode right;
	ExpressionNode left;
}
{
	right=expression4() ("||" left=expression4() { left = new LogicalOrNode(location(token), right, left); })*
							{
								return left;
							}
}

//論理AND
ExpressionNode expression4():
{
	ExpressionNode right;
	ExpressionNode left;
}
{
	left=expression3() ("&&" right=expression3() { left = new LogicalAndNode(location(token), right, left); })*
						   {
						   		return left;
						   }
}

//同等式
//関係式
ExpressionNode expression3():
{
	ExpressionNode right;
	ExpressionNode left;
}
{
	left=expression2() ( "==" right=expression2() { left = new EquivalenceNode(location(token), right, left); }
					   | "!=" right=expression2() { left = new NotEquivalenceNode(location(token), right, left); }
					   | "<"  right=expression2() { left = new LessThanNode(location(token), right, left); }
					   | ">"  right=expression2() { left = new GreaterThanNode(location(token), right, left); }
					   | "<=" right=expression2() { left = new LessThanOrEqualNode(location(token), right, left); }
					   | ">=" right=expression2() { left = new GreaterThanOrEqualNode(location(token), right, left); }
					   )*
							{
								return left;
							}
}

//加算式
//減算式
ExpressionNode expression2():
{
	ExpressionNode right;
	ExpressionNode left;
}
{
	left=expression1()  ( "+" right=expression1() { left = new PlusNode(location(token), right, left); }
						| "-" right=expression1() { left = new MinusNode(location(token), right, left); }
						)*
							{
								return left;
			   				}
}

//乗算式
//除算式
ExpressionNode expression1():
{
	ExpressionNode right;
	ExpressionNode left;
}
{
	left=term() ( "*" right=term() { left = new MulNode(location(token), right, left); }
		   		| "/" right=term() { left = new DivNode(location(token), right, left); }
		   		)*
		   			{						return left;
		   			}
}

//項の構文
ExpressionNode term():
{
	ExpressionNode expressionNode;
}
{
	expressionNode=unaryExpression() { return expressionNode; }
}

//単項式
ExpressionNode unaryExpression():
{
	Token token;
	ExpressionNode expressionNode;
}
{
	  "++" expressionNode=unaryExpression() { return new PreIncrementNode(location(token), expressionNode); } //前置増分式
	| "--" expressionNode=unaryExpression() { return new PreDecrementNode(location(token), expressionNode); } //前置減分式
	| "-" expressionNode=unaryExpression() { return new UnaryMinusNode(location(token), expressionNode); } //単項マイナス式
	| "!" expressionNode=unaryExpression() { return new ExclamationNode(location(token), expressionNode); } //論理否定
	| expressionNode=PostfixExpression() { return expressionNode; } //後置式
}

//後置式
ExpressionNode PostfixExpression():
{
	Token token;
	ExpressionNode expressionNode;
	ExpressionNode index;
	List<ExpressionNode> parameters;
}
{
	expressionNode=primaryExpression()
	( "++" { expressionNode = new PostIncrementNode(location(token), expressionNode); } //後置増分式
	| "--" { expressionNode = new PostDecrementNode(location(token), expressionNode); } //後置減分式
	| "[" index=expression() "]" { expressionNode = new ArraySubscriptExpressionNode(location(token), expressionNode, index) } //添字式
	| "(" parameters=parameters() ")" { expressionNode = new CallNode(location(token), expressionNode, parameters) } //関数呼び出し
	)*
		{
			return expressionNode;		}
}

//引数
List<ExpressionNode> parameters():
{
	List<ExpressionNode> parameters = new LinkedList<ExpressionNode>();
	ExpressionNode parameter;}
{
	[parameter=expression() { parameters.add(parameter); }
	("," parameter=expression() { parameters.add(parameter); })* ]
		{
			return parameters;		}}

//一次式
ExpressionNode primaryExpression():
{
	Token token;
	ExpressionNode expressionNode;
}
{
	token=<INTEGER> //10進定数
			{
				new LiteralNode(location(token), DataType.INT, token.image);
			}
	| token=<STRING> //文字列定数
			{
				new LiteralNode(location(token), DataType.STRING, token.image);
			}
	| token=<IDENTIFIER> //識別子
			{
				new IdentifierNode(location(token), token.image);
			}
	| "(" expressionNode=expression() ")" //括弧式			{
				return expressionNode;			}
}

